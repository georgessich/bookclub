"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newHTTPGraphQLHead = exports.cloneObject = exports.prettyJSONStringify = exports.runHttpQuery = exports.badMethodErrorMessage = exports.HeaderMap = void 0;
const ApolloServer_js_1 = require("./ApolloServer.js");
const graphql_1 = require("graphql");
const internalErrorClasses_js_1 = require("./internalErrorClasses.js");
const url_1 = require("url");
class HeaderMap extends Map {
    set(key, value) {
        if (key.toLowerCase() !== key) {
            throw Error(`Headers must be lower-case, unlike ${key}`);
        }
        return super.set(key, value);
    }
}
exports.HeaderMap = HeaderMap;
function fieldIfString(o, fieldName) {
    const value = o[fieldName];
    if (typeof value === 'string') {
        return value;
    }
    return undefined;
}
function searchParamIfSpecifiedOnce(searchParams, paramName) {
    const values = searchParams.getAll(paramName);
    switch (values.length) {
        case 0:
            return undefined;
        case 1:
            return values[0];
        default:
            throw new internalErrorClasses_js_1.BadRequestError(`The '${paramName}' search parameter may only be specified once.`);
    }
}
function jsonParsedSearchParamIfSpecifiedOnce(searchParams, fieldName) {
    const value = searchParamIfSpecifiedOnce(searchParams, fieldName);
    if (value === undefined) {
        return undefined;
    }
    let hopefullyRecord;
    try {
        hopefullyRecord = JSON.parse(value);
    }
    catch {
        throw new internalErrorClasses_js_1.BadRequestError(`The ${fieldName} search parameter contains invalid JSON.`);
    }
    if (!isStringRecord(hopefullyRecord)) {
        throw new internalErrorClasses_js_1.BadRequestError(`The ${fieldName} search parameter should contain a JSON-encoded object.`);
    }
    return hopefullyRecord;
}
function fieldIfRecord(o, fieldName) {
    const value = o[fieldName];
    if (isStringRecord(value)) {
        return value;
    }
    return undefined;
}
function isStringRecord(o) {
    return (!!o && typeof o === 'object' && !Buffer.isBuffer(o) && !Array.isArray(o));
}
function isNonEmptyStringRecord(o) {
    return isStringRecord(o) && Object.keys(o).length > 0;
}
function ensureQueryIsStringOrMissing(query) {
    if (!query || typeof query === 'string') {
        return;
    }
    if (query.kind === graphql_1.Kind.DOCUMENT) {
        throw new internalErrorClasses_js_1.BadRequestError("GraphQL queries must be strings. It looks like you're sending the " +
            'internal graphql-js representation of a parsed query in your ' +
            'request instead of a request in the GraphQL query language. You ' +
            'can convert an AST to a string using the `print` function from ' +
            '`graphql`, or use a client like `apollo-client` which converts ' +
            'the internal representation to a string for you.');
    }
    else {
        throw new internalErrorClasses_js_1.BadRequestError('GraphQL queries must be strings.');
    }
}
exports.badMethodErrorMessage = 'Apollo Server supports only GET/POST requests.';
async function runHttpQuery(server, httpRequest, contextValue, schemaDerivedData, internals) {
    let graphQLRequest;
    switch (httpRequest.method) {
        case 'POST': {
            if (!isNonEmptyStringRecord(httpRequest.body)) {
                throw new internalErrorClasses_js_1.BadRequestError('POST body missing, invalid Content-Type, or JSON object has no keys.');
            }
            ensureQueryIsStringOrMissing(httpRequest.body.query);
            if (typeof httpRequest.body.variables === 'string') {
                throw new internalErrorClasses_js_1.BadRequestError('`variables` in a POST body should be provided as an object, not a recursively JSON-encoded string.');
            }
            if (typeof httpRequest.body.extensions === 'string') {
                throw new internalErrorClasses_js_1.BadRequestError('`extensions` in a POST body should be provided as an object, not a recursively JSON-encoded string.');
            }
            graphQLRequest = {
                query: fieldIfString(httpRequest.body, 'query'),
                operationName: fieldIfString(httpRequest.body, 'operationName'),
                variables: fieldIfRecord(httpRequest.body, 'variables'),
                extensions: fieldIfRecord(httpRequest.body, 'extensions'),
                http: httpRequest,
            };
            break;
        }
        case 'GET': {
            const searchParams = new url_1.URLSearchParams(httpRequest.search);
            graphQLRequest = {
                query: searchParamIfSpecifiedOnce(searchParams, 'query'),
                operationName: searchParamIfSpecifiedOnce(searchParams, 'operationName'),
                variables: jsonParsedSearchParamIfSpecifiedOnce(searchParams, 'variables'),
                extensions: jsonParsedSearchParamIfSpecifiedOnce(searchParams, 'extensions'),
                http: httpRequest,
            };
            break;
        }
        default:
            throw new internalErrorClasses_js_1.BadRequestError(exports.badMethodErrorMessage);
    }
    const graphQLResponse = await (0, ApolloServer_js_1.internalExecuteOperation)({
        server,
        graphQLRequest,
        contextValue,
        internals,
        schemaDerivedData,
    });
    const body = prettyJSONStringify(orderExecutionResultFields(graphQLResponse.result));
    return {
        ...graphQLResponse.http,
        completeBody: body,
        bodyChunks: null,
    };
}
exports.runHttpQuery = runHttpQuery;
function orderExecutionResultFields(result) {
    return {
        errors: result.errors,
        data: result.data,
        extensions: result.extensions,
    };
}
function prettyJSONStringify(value) {
    return JSON.stringify(value) + '\n';
}
exports.prettyJSONStringify = prettyJSONStringify;
function cloneObject(object) {
    return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
}
exports.cloneObject = cloneObject;
function newHTTPGraphQLHead(status) {
    return {
        status,
        headers: new HeaderMap(),
    };
}
exports.newHTTPGraphQLHead = newHTTPGraphQLHead;
//# sourceMappingURL=runHttpQuery.js.map