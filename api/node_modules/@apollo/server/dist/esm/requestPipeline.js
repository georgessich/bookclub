import { createHash } from '@apollo/utils.createhash';
import { specifiedRules, getOperationAST, GraphQLError, validate, parse, execute as graphqlExecute, Kind, } from 'graphql';
import { symbolExecutionDispatcherWillResolveField, enablePluginsForSchemaResolvers, symbolUserFieldResolver, } from './utils/schemaInstrumentation.js';
import { PersistedQueryNotSupportedError, PersistedQueryNotFoundError, UserInputError, BadRequestError, ValidationError, SyntaxError, OperationResolutionError, } from './internalErrorClasses.js';
import { ensureError, normalizeAndFormatErrors, ensureGraphQLError, } from './errorNormalize.js';
import { invokeDidStartHook, invokeHooksUntilDefinedAndNonNull, invokeSyncDidStartHook, } from './utils/invokeHooks.js';
import { makeGatewayGraphQLRequestContext } from './utils/makeGatewayGraphQLRequestContext.js';
import { HeaderMap, newHTTPGraphQLHead } from './runHttpQuery.js';
import { isDefined } from './utils/isDefined.js';
export const APQ_CACHE_PREFIX = 'apq:';
function computeQueryHash(query) {
    return createHash('sha256').update(query).digest('hex');
}
function isBadUserInputGraphQLError(error) {
    return (error.nodes?.length === 1 &&
        error.nodes[0].kind === Kind.VARIABLE_DEFINITION &&
        (error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" got invalid value `) ||
            error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of required type `) ||
            error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of non-null type `)));
}
const getPersistedQueryErrorHttp = () => ({
    status: 200,
    headers: new HeaderMap([
        ['cache-control', 'private, no-cache, must-revalidate'],
    ]),
});
export async function processGraphQLRequest(schemaDerivedData, server, internals, requestContext) {
    const requestListeners = (await Promise.all(internals.plugins.map((p) => p.requestDidStart?.(requestContext)))).filter(isDefined);
    const request = requestContext.request;
    let { query, extensions } = request;
    let queryHash;
    requestContext.metrics.persistedQueryHit = false;
    requestContext.metrics.persistedQueryRegister = false;
    if (extensions?.persistedQuery) {
        if (!internals.persistedQueries) {
            return await sendErrorResponse([new PersistedQueryNotSupportedError()], getPersistedQueryErrorHttp());
        }
        else if (extensions.persistedQuery.version !== 1) {
            return await sendErrorResponse([
                new GraphQLError('Unsupported persisted query version'),
            ]);
        }
        queryHash = extensions.persistedQuery.sha256Hash;
        if (query === undefined) {
            query = await internals.persistedQueries.cache.get(queryHash);
            if (query) {
                requestContext.metrics.persistedQueryHit = true;
            }
            else {
                return await sendErrorResponse([new PersistedQueryNotFoundError()], getPersistedQueryErrorHttp());
            }
        }
        else {
            const computedQueryHash = computeQueryHash(query);
            if (queryHash !== computedQueryHash) {
                return await sendErrorResponse([
                    new GraphQLError('provided sha does not match query'),
                ]);
            }
            requestContext.metrics.persistedQueryRegister = true;
        }
    }
    else if (query) {
        queryHash = computeQueryHash(query);
    }
    else {
        return await sendErrorResponse([
            new BadRequestError('GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.'),
        ]);
    }
    requestContext.queryHash = queryHash;
    requestContext.source = query;
    await Promise.all(requestListeners.map((l) => l.didResolveSource?.(requestContext)));
    if (schemaDerivedData.documentStore) {
        try {
            requestContext.document = await schemaDerivedData.documentStore.get(queryHash);
        }
        catch (err) {
            server.logger.warn('An error occurred while attempting to read from the documentStore. ' +
                ensureError(err).message);
        }
    }
    if (!requestContext.document) {
        const parsingDidEnd = await invokeDidStartHook(requestListeners, async (l) => l.parsingDidStart?.(requestContext));
        try {
            requestContext.document = parse(query, internals.parseOptions);
        }
        catch (syntaxMaybeError) {
            const error = ensureError(syntaxMaybeError);
            await parsingDidEnd(error);
            return await sendErrorResponse([
                new SyntaxError(ensureGraphQLError(error)),
            ]);
        }
        await parsingDidEnd();
        const validationDidEnd = await invokeDidStartHook(requestListeners, async (l) => l.validationDidStart?.(requestContext));
        const validationErrors = validate(schemaDerivedData.schema, requestContext.document, [...specifiedRules, ...internals.validationRules]);
        if (validationErrors.length === 0) {
            await validationDidEnd();
        }
        else {
            await validationDidEnd(validationErrors);
            return await sendErrorResponse(validationErrors.map((error) => new ValidationError(error)));
        }
        if (schemaDerivedData.documentStore) {
            Promise.resolve(schemaDerivedData.documentStore.set(queryHash, requestContext.document)).catch((err) => server.logger.warn('Could not store validated document. ' + err?.message || err));
        }
    }
    const operation = getOperationAST(requestContext.document, request.operationName);
    requestContext.operation = operation || undefined;
    requestContext.operationName = operation?.name?.value || null;
    if (request.http?.method === 'GET' &&
        operation?.operation &&
        operation.operation !== 'query') {
        return await sendErrorResponse([
            new BadRequestError(`GET requests only support query operations, not ${operation.operation} operations`),
        ], { status: 405, headers: new HeaderMap([['allow', 'POST']]) });
    }
    try {
        await Promise.all(requestListeners.map((l) => l.didResolveOperation?.(requestContext)));
    }
    catch (err) {
        return await sendErrorResponse([ensureGraphQLError(err)], newHTTPGraphQLHead(500));
    }
    if (requestContext.metrics.persistedQueryRegister &&
        internals.persistedQueries) {
        const ttl = internals.persistedQueries?.ttl;
        Promise.resolve(internals.persistedQueries.cache.set(queryHash, query, ttl !== undefined
            ? { ttl: internals.persistedQueries?.ttl }
            : undefined)).catch(server.logger.warn);
    }
    const responseFromPlugin = await invokeHooksUntilDefinedAndNonNull(requestListeners, async (l) => await l.responseForOperation?.(requestContext));
    if (responseFromPlugin !== null) {
        requestContext.response.result = responseFromPlugin.result;
        updateResponseHTTP(responseFromPlugin.http);
    }
    else {
        const executionListeners = (await Promise.all(requestListeners.map((l) => l.executionDidStart?.(requestContext)))).filter(isDefined);
        executionListeners.reverse();
        if (executionListeners.some((l) => l.willResolveField)) {
            const invokeWillResolveField = (...args) => invokeSyncDidStartHook(executionListeners, (l) => l.willResolveField?.(...args));
            Object.defineProperty(requestContext.contextValue, symbolExecutionDispatcherWillResolveField, { value: invokeWillResolveField });
            if (internals.fieldResolver) {
                Object.defineProperty(requestContext.contextValue, symbolUserFieldResolver, {
                    value: internals.fieldResolver,
                });
            }
            enablePluginsForSchemaResolvers(schemaDerivedData.schema);
        }
        let statusIfExecuteThrows = 500;
        try {
            const result = await execute(requestContext);
            if (!requestContext.operation) {
                if (!result.errors?.length) {
                    throw new Error('Unexpected error: Apollo Server did not resolve an operation but execute did not return errors');
                }
                statusIfExecuteThrows = 400;
                throw new OperationResolutionError(result.errors[0]);
            }
            const resultErrors = result.errors?.map((e) => {
                if (isBadUserInputGraphQLError(e)) {
                    return new UserInputError(e);
                }
                return e;
            });
            if (resultErrors) {
                await didEncounterErrors(resultErrors);
            }
            requestContext.response.result = {
                ...result,
                errors: resultErrors ? formatErrors(resultErrors) : undefined,
            };
            await Promise.all(executionListeners.map((l) => l.executionDidEnd?.()));
        }
        catch (executionMaybeError) {
            const executionError = ensureError(executionMaybeError);
            await Promise.all(executionListeners.map((l) => l.executionDidEnd?.(executionError)));
            return await sendErrorResponse([ensureGraphQLError(executionError)], newHTTPGraphQLHead(statusIfExecuteThrows));
        }
    }
    await invokeWillSendResponse();
    return;
    async function execute(requestContext) {
        const { request, document } = requestContext;
        if (internals.gatewayExecutor) {
            const result = await internals.gatewayExecutor(makeGatewayGraphQLRequestContext(requestContext, server, internals));
            return result;
        }
        else {
            return await graphqlExecute({
                schema: schemaDerivedData.schema,
                document,
                rootValue: typeof internals.rootValue === 'function'
                    ? internals.rootValue(document)
                    : internals.rootValue,
                contextValue: requestContext.contextValue,
                variableValues: request.variables,
                operationName: request.operationName,
                fieldResolver: internals.fieldResolver,
            });
        }
    }
    function updateResponseHTTP(http) {
        if (http.status) {
            requestContext.response.http.status = http.status;
        }
        for (const [name, value] of http.headers) {
            requestContext.response.http.headers.set(name, value);
        }
    }
    async function invokeWillSendResponse() {
        await Promise.all(requestListeners.map((l) => l.willSendResponse?.(requestContext)));
    }
    async function didEncounterErrors(errors) {
        requestContext.errors = errors;
        return await Promise.all(requestListeners.map((l) => l.didEncounterErrors?.(requestContext)));
    }
    async function sendErrorResponse(errors, http = newHTTPGraphQLHead()) {
        await didEncounterErrors(errors);
        requestContext.response.result = {
            errors: formatErrors(errors),
        };
        updateResponseHTTP(http);
        if (!requestContext.response.http.status) {
            requestContext.response.http.status = 400;
        }
        await invokeWillSendResponse();
    }
    function formatErrors(errors) {
        return normalizeAndFormatErrors(errors, {
            formatError: internals.formatError,
            includeStacktraceInErrorResponses: internals.includeStacktraceInErrorResponses,
        });
    }
}
//# sourceMappingURL=requestPipeline.js.map