import type { Logger } from '@apollo/utils.logger';
import { Resolvable } from '@josephg/resolvable';
import { DocumentNode, GraphQLFieldResolver, GraphQLFormattedError, GraphQLSchema, ParseOptions, ValidationContext } from 'graphql';
import { type KeyValueCache } from '@apollo/utils.keyvaluecache';
import type { ApolloServerPlugin, BaseContext, GraphQLRequest, GraphQLResponse, HTTPGraphQLRequest, HTTPGraphQLResponse, LandingPage, ApolloConfig, ApolloServerOptions, DocumentStore, PersistedQueryOptions, ContextThunk } from './externalTypes';
import { SchemaManager } from './utils/schemaManager.js';
import type { WithRequired } from '@apollo/utils.withrequired';
import type { GatewayExecutor } from '@apollo/server-gateway-interface';
export declare type SchemaDerivedData = {
    schema: GraphQLSchema;
    documentStore: DocumentStore | null;
};
declare type RunningServerState = {
    schemaManager: SchemaManager;
    landingPage: LandingPage | null;
};
declare type ServerState = {
    phase: 'initialized';
    schemaManager: SchemaManager;
} | {
    phase: 'starting';
    barrier: Resolvable<void>;
    schemaManager: SchemaManager;
    startedInBackground: boolean;
} | {
    phase: 'failed to start';
    error: Error;
} | ({
    phase: 'started';
    drainServers: (() => Promise<void>) | null;
    toDispose: (() => Promise<void>)[];
    toDisposeLast: (() => Promise<void>)[];
} & RunningServerState) | ({
    phase: 'draining';
    barrier: Resolvable<void>;
} & RunningServerState) | {
    phase: 'stopping';
    barrier: Resolvable<void>;
} | {
    phase: 'stopped';
    stopError: Error | null;
};
export interface ApolloServerInternals<TContext extends BaseContext> {
    formatError?: (formattedError: GraphQLFormattedError, error: unknown) => GraphQLFormattedError;
    rootValue?: ((parsedQuery: DocumentNode) => any) | any;
    validationRules: Array<(context: ValidationContext) => any>;
    fieldResolver?: GraphQLFieldResolver<any, TContext>;
    includeStacktraceInErrorResponses: boolean;
    persistedQueries?: WithRequired<PersistedQueryOptions, 'cache'>;
    nodeEnv: string;
    allowBatchedHttpRequests: boolean;
    apolloConfig: ApolloConfig;
    plugins: ApolloServerPlugin<TContext>[];
    parseOptions: ParseOptions;
    state: ServerState;
    stopOnTerminationSignals: boolean | undefined;
    gatewayExecutor: GatewayExecutor | null;
    csrfPreventionRequestHeaders: string[] | null;
}
export declare class ApolloServer<in out TContext extends BaseContext = BaseContext> {
    private internals;
    readonly cache: KeyValueCache<string>;
    readonly logger: Logger;
    constructor(config: ApolloServerOptions<TContext>);
    start(): Promise<void>;
    startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests(): void;
    private _start;
    private maybeRegisterTerminationSignalHandlers;
    private _ensureStarted;
    assertStarted(expressionForError: string): void;
    private logStartupError;
    private static constructSchema;
    private static generateSchemaDerivedData;
    stop(): Promise<void>;
    private addDefaultPlugins;
    addPlugin(plugin: ApolloServerPlugin<TContext>): void;
    executeHTTPGraphQLRequest({ httpGraphQLRequest, context, }: {
        httpGraphQLRequest: HTTPGraphQLRequest;
        context: ContextThunk<TContext>;
    }): Promise<HTTPGraphQLResponse>;
    private errorResponse;
    private prefersHTML;
    executeOperation(this: ApolloServer<BaseContext>, request: Omit<GraphQLRequest, 'query'> & {
        query?: string | DocumentNode;
    }): Promise<GraphQLResponse>;
    executeOperation(request: Omit<GraphQLRequest, 'query'> & {
        query?: string | DocumentNode;
    }, contextValue: TContext): Promise<GraphQLResponse>;
}
export declare function internalExecuteOperation<TContext extends BaseContext>({ server, graphQLRequest, contextValue, internals, schemaDerivedData, }: {
    server: ApolloServer<TContext>;
    graphQLRequest: GraphQLRequest;
    contextValue: TContext;
    internals: ApolloServerInternals<TContext>;
    schemaDerivedData: SchemaDerivedData;
}): Promise<GraphQLResponse>;
export declare type ImplicitlyInstallablePlugin<TContext extends BaseContext> = ApolloServerPlugin<TContext> & {
    __internal_installed_implicitly__: boolean;
};
export declare function isImplicitlyInstallablePlugin<TContext extends BaseContext>(p: ApolloServerPlugin<TContext>): p is ImplicitlyInstallablePlugin<TContext>;
export {};
//# sourceMappingURL=ApolloServer.d.ts.map