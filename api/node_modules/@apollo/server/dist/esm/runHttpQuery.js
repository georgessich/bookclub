import { internalExecuteOperation, } from './ApolloServer.js';
import { Kind } from 'graphql';
import { BadRequestError } from './internalErrorClasses.js';
import { URLSearchParams } from 'url';
export class HeaderMap extends Map {
    set(key, value) {
        if (key.toLowerCase() !== key) {
            throw Error(`Headers must be lower-case, unlike ${key}`);
        }
        return super.set(key, value);
    }
}
function fieldIfString(o, fieldName) {
    const value = o[fieldName];
    if (typeof value === 'string') {
        return value;
    }
    return undefined;
}
function searchParamIfSpecifiedOnce(searchParams, paramName) {
    const values = searchParams.getAll(paramName);
    switch (values.length) {
        case 0:
            return undefined;
        case 1:
            return values[0];
        default:
            throw new BadRequestError(`The '${paramName}' search parameter may only be specified once.`);
    }
}
function jsonParsedSearchParamIfSpecifiedOnce(searchParams, fieldName) {
    const value = searchParamIfSpecifiedOnce(searchParams, fieldName);
    if (value === undefined) {
        return undefined;
    }
    let hopefullyRecord;
    try {
        hopefullyRecord = JSON.parse(value);
    }
    catch {
        throw new BadRequestError(`The ${fieldName} search parameter contains invalid JSON.`);
    }
    if (!isStringRecord(hopefullyRecord)) {
        throw new BadRequestError(`The ${fieldName} search parameter should contain a JSON-encoded object.`);
    }
    return hopefullyRecord;
}
function fieldIfRecord(o, fieldName) {
    const value = o[fieldName];
    if (isStringRecord(value)) {
        return value;
    }
    return undefined;
}
function isStringRecord(o) {
    return (!!o && typeof o === 'object' && !Buffer.isBuffer(o) && !Array.isArray(o));
}
function isNonEmptyStringRecord(o) {
    return isStringRecord(o) && Object.keys(o).length > 0;
}
function ensureQueryIsStringOrMissing(query) {
    if (!query || typeof query === 'string') {
        return;
    }
    if (query.kind === Kind.DOCUMENT) {
        throw new BadRequestError("GraphQL queries must be strings. It looks like you're sending the " +
            'internal graphql-js representation of a parsed query in your ' +
            'request instead of a request in the GraphQL query language. You ' +
            'can convert an AST to a string using the `print` function from ' +
            '`graphql`, or use a client like `apollo-client` which converts ' +
            'the internal representation to a string for you.');
    }
    else {
        throw new BadRequestError('GraphQL queries must be strings.');
    }
}
export const badMethodErrorMessage = 'Apollo Server supports only GET/POST requests.';
export async function runHttpQuery(server, httpRequest, contextValue, schemaDerivedData, internals) {
    let graphQLRequest;
    switch (httpRequest.method) {
        case 'POST': {
            if (!isNonEmptyStringRecord(httpRequest.body)) {
                throw new BadRequestError('POST body missing, invalid Content-Type, or JSON object has no keys.');
            }
            ensureQueryIsStringOrMissing(httpRequest.body.query);
            if (typeof httpRequest.body.variables === 'string') {
                throw new BadRequestError('`variables` in a POST body should be provided as an object, not a recursively JSON-encoded string.');
            }
            if (typeof httpRequest.body.extensions === 'string') {
                throw new BadRequestError('`extensions` in a POST body should be provided as an object, not a recursively JSON-encoded string.');
            }
            graphQLRequest = {
                query: fieldIfString(httpRequest.body, 'query'),
                operationName: fieldIfString(httpRequest.body, 'operationName'),
                variables: fieldIfRecord(httpRequest.body, 'variables'),
                extensions: fieldIfRecord(httpRequest.body, 'extensions'),
                http: httpRequest,
            };
            break;
        }
        case 'GET': {
            const searchParams = new URLSearchParams(httpRequest.search);
            graphQLRequest = {
                query: searchParamIfSpecifiedOnce(searchParams, 'query'),
                operationName: searchParamIfSpecifiedOnce(searchParams, 'operationName'),
                variables: jsonParsedSearchParamIfSpecifiedOnce(searchParams, 'variables'),
                extensions: jsonParsedSearchParamIfSpecifiedOnce(searchParams, 'extensions'),
                http: httpRequest,
            };
            break;
        }
        default:
            throw new BadRequestError(badMethodErrorMessage);
    }
    const graphQLResponse = await internalExecuteOperation({
        server,
        graphQLRequest,
        contextValue,
        internals,
        schemaDerivedData,
    });
    const body = prettyJSONStringify(orderExecutionResultFields(graphQLResponse.result));
    return {
        ...graphQLResponse.http,
        completeBody: body,
        bodyChunks: null,
    };
}
function orderExecutionResultFields(result) {
    return {
        errors: result.errors,
        data: result.data,
        extensions: result.extensions,
    };
}
export function prettyJSONStringify(value) {
    return JSON.stringify(value) + '\n';
}
export function cloneObject(object) {
    return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
}
export function newHTTPGraphQLHead(status) {
    return {
        status,
        headers: new HeaderMap(),
    };
}
//# sourceMappingURL=runHttpQuery.js.map